[{"content":"程序的概念与发展 程序的定义 一般的讲，程序是一系列有序指令的集合，目的是告诉计算机如何完成某些指定的操作或者如何解决某个问题。\n编程语言的发展历程 早期：采用机器语言设计程序，开发效率极低。\n中期：出现汇编语言，但不同平台的汇编指令集不兼容，增加了开发难度。\n后期：为提升开发效率、降低难度，诞生高级语言。其中，C 语言属于面向过程编程，C++ 属于面向对象编程，此外还有 Python、Java 等多种编程语言。\n编程领域重要人物及贡献 程序的文件格式 程序的格式和类型由所使用的编程语言决定，不同编程语言对应不同的源文件后缀名，例如：\nC 语言：.c 后缀 Python 语言：.py 后缀 程序的运行原理 程序无法直接运行，需经编译器等工具处理转换为可执行文件（内部包含对应平台可识别的指令和数据集合）。运行可执行文件的本质，是计算机中央处理器（CPU）对其中的指令进行处理、对数据进行运算的过程。\n计算机组成与程序执行流程 计算机组成：遵循冯・诺依曼结构，由控制器、运算器、存储器、输入设备、输出设备五部分组成。 程序执行依赖：需掌握计算机组成原理和汇编语言，才能理解程序中指令和数据的具体执行流程。 程序运行的内存模型（32 位系统） 程序的编译过程 编译的必要性 编写完成的程序无法直接运行，需通过编译器编译生成可执行文件，嵌入式学习中常在 Linux 系统下使用 GCC 编译器。\nGCC 编译器简介 GCC编译器是Linux系统默认的C/C++编译器，大部分Linux发行版本中都是默认安装的。GCC编译器主要以Linux命令的形式在shell终端中使用，所以需要大家掌握关于GCC编译器的相关参数。\nC 语言程序编译四步骤 C语言程序编译过程：源程序 \u0026mdash;- 预处理 \u0026mdash; 编译 \u0026mdash; 汇编 \u0026mdash; 链接 \u0026mdash; 可执行文件\n预处理：\n对源码进行简单的加工，GCC编译器会调用预处理器cpp对程序进行预处理，其实就是解释源程序中所有的预处理指令，如#include（文件包含）、#define（宏定义）、#if（条件编译）等以#号开头的预处理语句。\n这些预处理指令将会在预处理阶段被解释掉，如会把被包含的文件拷贝进来，覆盖掉原来的#include语句，把所有的宏定义展开，所有的条件编译语句被执行，GCC还会把所有的注释删掉，添加必要的调试信息。\n预处理指令： gcc -E xxx.c -o xxx.i 会生成预处理文件 xxx.i\n编译：\n就是对经过预处理之后的.i文件进行进一步翻译，也就是对语法、词法的分析，最终生成对应硬件平台的汇编文件，具体生成什么平台的汇编文件取决于编译器，比如X86平台使用gcc编译器，而ARM平台使用交叉编译工具arm-linux-gcc。\n编译指令：gcc -S xxx.i -o xxx.s 会生成对应汇编文件 xxx.s\n汇编：\nGCC编译器会调用汇编器as将汇编文件翻译成可重定位文件，其实就是把.s文件的汇编代码翻译为相应的指令。\n编译指令：gcc -c xxx.s -o xxx.o 会生成汇编后的文件 xxx.o\n链接：\n经过汇编步骤后生成的.o文件其实是ELF格式的可重定位文件，虽然已经生成了指令流，但是需要重定位函数地址等，所以需要链接系统提供的标准C库和其他的gcc基本库文件等，并且还要把其他的.o文件一起进行链接。默认链接 -lc（libc 标准库） -lgcc 是默认的，可以省略\n编译指令：gcc hello.o -o hello -lc -lgcc 会得到可执行文件 xxx // l是lib的缩写\n程序的格式与目标文件 目标文件与可执行文件 目标文件（.o 文件）：又称可重定位文件，是未完成链接的中间文件，可制作成 Linux 系统下的静态库（libxxx.a）或动态库（libxxx.so）。\n可执行文件：完成链接后的文件，与目标文件同属 ELF（Executable Linkable Format，可执行可链接格式）。\n查看文件格式：Linux 系统中使用file指令，例如file demo.o可查看目标文件属性，file demo可查看可执行文件属性。\n注意：可以在linux系统中利用查看文件格式的指令: file 查阅目标文件和可执行文件的区别：\n目标文件的内容与结构 还未完成链接的目标文件中存储了哪些内容，以及如何查看目标文件中的内容信息???\n目标文件中的内容至少有编译后的机器指令代码、数据。除了这些内容以外，目标文件中还包括了链接时所需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”(Section)的形式存储，有时候也叫“段”(Segment),一般情况下，它们都表示一个一定长度的区域，基本上不加以区别。\n程序源代码编译后的机器指令经常被放在代码段(Code Section)里，代码段常见的名字有“.code”或“.text”。全局变量和局部静态变量数据经常放在数据段(Data Section)，数据段一般名字都叫“.data”。\n注意：linux系统的GCC编译套件有一款工具叫做objdump，可以查看目标文件内部的数据！\n数据段中有一个叫做**.bss段**， bss以前其实是汇编伪指令，作用是为某些数据预留一块空间，bss其实是Block Started by Symbol，也就是用于存储未被初始化的全局变量和静态局部变量，但是在程序编译阶段是没有分配空间的，在程序运行时会得到空间。\n得到了运行空间\n*常用的段名* *说* *明* .rodatal 这种段里存放的是只读数据，比如字符串常量、全局const变量。跟\u0026quot;.rodata\u0026quot;一样 .comment 存放的是编译器版本信息，比如字符串：“GCC:(GNU)4.2.0” .debug 调试信息 .dynamic 动态链接信息 .hash 符号哈希表 .line 调试时的行号表，即源代码行号与编译后指令的对应表 .note 额外的编译器信息。比如程序的公司名、发布版本号等 .strtab String Table.字符串表，用于存储ELF文件中用到的各种字符串 .symtab Symbol Table.符号表 .shstrtab Section String Table.段名表 .plt 动态链接的跳转表和全局入口表 .init 程序初始化与终结代码段。 另外，objdump工具也可以实现把可执行文件进行反汇编，可以把得到的反汇编代码重定向到某个文本中进行查看 “objdump -D demo \u0026gt; \u0026gt; xxx.txt”\n进程的概念与特征 进程的定义 当 ELF 可执行文件运行时，操作系统将文件中的指令和数据从外存加载到内存，为其分配内存空间、CPU 使用权等系统资源，程序从静态变为动态，这种正在执行的程序实例称为进程。进程是操作系统分配资源的基本单位！操作系统是以进程为单位来分配系统资源的，比如内存空间、CPU使用权等。 线程是操作系统调度资源的最小单位！ 进程包含线程！\n进程与程序的区别 特性 程序 进程 状态 静态（存储于磁盘） 动态（运行于内存） 资源占用 不占用系统资源 占用内存、CPU 等系统资源 存在形式 文本文件 包含 PCB、代码段、数据段的运行实体 进程的四大特征 进程具有四个基本特征，分别是动态性、并发性、独立性、异步性，具体的区别如下所示：\n动态性：进程是程序在处理器上的一次执行过程，会经历创建、暂停、继续执行、终止等状态变化。 并发性：多个进程可同时存在于内存中，并发执行以提高资源利用率。 独立性：进程是能独立运行的基本单位，也是系统资源分配和调度的独立单位。 异步性：进程以各自独立、不可预知的速度推进，执行进度受系统资源分配、其他进程抢占等因素影响。 进程的组成与管理 操作系统中可能会有n个进程同时执行，请问操作系统如何掌握这些进程的执行情况?\n一般进程在创建之后，操作系统都会为进程分配一块内存来记录进程的各项参数信息，所以这块内存被称为进程控制块（Processing Control Block，缩写为PCB）。每个进程都有PCB，用于标识进程的存在以及记录进程的信息。\n进程的组成 进程由进程控制块（PCB）、代码段、数据段三部分组成：\n进程控制块（PCB）：操作系统为进程分配的内存区域，用于记录进程各项参数信息，标识进程存在，Linux 系统中以struct task_struct结构体存储（定义于sched.h头文件）。\n代码段：可被调度程序调度到 CPU 执行的程序代码。\n数据段：包含程序原始数据和执行过程中产生的中间数据。\nPCB 的核心内容 进程标识符 每个进程都有一个有系统分配的唯一的PID进程标识符（process identifier），用于区分系统中的其他进程，这个PID也是Linux内核提供给用户访问进程的一个接口，用户可以通过PID控制进程。\n比如Windows系统可以通过任务管理器了解系统中正在执行的进程的数量以及进程的状态：\n那Linux系统如何查看进程PID?\nLinux系统中提供了关于获取进程状态的shell命令：ps ，该命令的使用方法详见man手册，一般使用 ps -ef 或者 ps -aux来查看Linux系统中所有用户相关的进程的所有信息。\n进程当前状态 在进程的运行过程中由于系统中多个进程的并发运行和相互制约的结果，所以使进程的状态不断发生变化。操作系统以进程的状态来作为调度程序分配处理器的依据。\n通常一个运行中的进程至少可划分为5种基本状态：就绪态、运行态、阻塞态、创建态、结束态。\n状态 说明 创建态 进程正在创建，系统分配 PCB 内存、填写管理信息、分配资源，未达到就绪态 就绪态 已获得除处理器外的所有资源，等待 CPU 调度，获得后可立即执行 执行态（运行态） 已获得所有资源（含 CPU），正在被 CPU 执行 阻塞态（暂停态） 执行过程中因某事件（如 sleep、read）无法继续，暂时停止 结束态 进程正常退出或异常中断，从系统中消失；若退出后资源未释放，进入僵尸态 僵尸态 进程终止但未释放资源，需用户处理，避免占用过多系统资源 其他信息：包括进程优先级、CPU 使用情况、内存占用情况、打开文件描述符等\n在Linux系统的终端中输入shell指令： ps -aux，就可以看到当前系统中运行的进程状态。\n标识 状态含义 D 不可中断睡眠（通常为 I/O 操作） I 空闲内核线程 R 运行态或就绪态（在运行队列中） S 可中断睡眠（等待事件完成） T 被作业控制信号停止 t 调试过程中被调试器停止 W 分页（2.6.x 内核后无效） X 死亡（极少出现） Z 僵尸态（已终止但未被父进程回收） 注意：进程不是一直处于某一个状态，进程的状态会受到外界因素和执行进度的影响而发生改变，当然，进程的状态在某一个时刻是唯一的，也就是在某一时刻进程必须且只能处于一种状态。\n进程的控制操作 进程控制指的是对系统中的所有进程实施有效的管理，其功能一般包括进程的创建、进程的撤销、进程的阻塞与唤醒等。这些功能一般是由操作系统的内核来实现的。\n进程的创建 进程关系 Linux系统中的一个进程中可以创建若干个新进程，新创建的进程中又可以创建子进程，所以一般使用****进程前趋图来描述创建的进程之间的关系****。进程前趋图也被称为进程树，是为了描述进程家族关系的树。\n比如在进程A中创建了一个新进程B，则进程B就是进程A的子进程，进程A就是进程B的父进程。\n如果在进程A中创建了2个子进程B和C，进程B中创建了2个子进程D和E，进程C中创建了1个子进程F，则进程A就是该进程家族的祖先。\n查看进程树 在Linux系统中运行的所有进程也可以构成一个进程树，并且该进程树也有一个祖先，用户可以通过Linux系统提供的shell命令：pstree 来打印进程关系。\n所有进程的祖先为systemd进程（PID=1），即系统守护进程，负责系统启动时激活资源、管理其他进程。\n守护进程也被翻译为精灵进程或者后台进程，是一种旨在运行于相对干净环境、不受终端影响的、常驻内存的进程，拥有不死的特性，长期稳定提供某种功能或服务。\nsystemd其实是一个 Linux 系统基础组件的集合，它提供了一个系统和服务管理器，然后运行为 PID 1的进程，负责在系统启动或运行时激活系统资源，并且管理服务器进程和其它进程。\n创建接口 Linux系统中只有进程才可以在系统运行，所以一个程序想要运行，就必须为该程序创建进程。linux内核提供了一个名字叫做**fork()**的系统调用接口，该接口可以在进程中创建一个子进程。\nfork()特性：\n子进程复制父进程的代码段、数据段、堆栈段，但拥有独立内存空间，父进程与子进程的内存操作互不影响。 返回值：父进程中返回子进程 PID；子进程中返回 0；创建失败时父进程返回 - 1。 执行顺序：父进程与子进程的执行顺序由操作系统调度器决定，可通过特定机制调整。 通过fork函数的返回值来区分父进程和子进程\n获取当前进程PID的函数接口getpid()，获取当前进程的父进程PID的函数接口是getppid()\n练习 编写程序，要求在程序中创建一个子进程，让父进程和子进程分别打印不同的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(int argc, const char *argv[]) { // 创建一个子进程 pid_t pid = fork(); // fork()函数返回值的判断 if(pid\u0026gt;0){// 父进程 printf(\u0026#34;Parent process, pid: %d,My child pid: %d\\n\u0026#34;, getpid(), pid); while(1) ; } else if(pid==0){// 子进程 printf(\u0026#34;Child process, pid: %d,My parent pid: %d\\n\u0026#34;, getpid(), getppid()); }else{ perror(\u0026#34;fork error\u0026#34;); return -1; } return 0; } 为什么会出现子进程的父进程的pid为1，因为当父进程的语句执行完后return结束了，就是子进程的父亲死了，所以由守护进程来看管刚才的子进程。\n调用fork函数之后可以创建一个子进程，但是调用了一次fork函数为什么会有两个不同的返回值？\n就是调用fork的时候子进程已经拷贝了父进程的代码段、数据段、堆栈段，所以fork函数还没有执行完成，就会在两个进程空间继续执行，就会得到两个不同的返回值。\n进程的撤销 一个进程在完成自身任务之后应该及时撤销，这样就可以及时的释放进程的资源，此时可以分为两种情况：一种是撤销指定进程，另一种是撤销指定进程以及该进程的所有子孙进程。不管是哪种情况，都应该及时回收进程占用的资源。\nLinux系统中提供了一个名称叫做**wait()**的系统调用接口，该接口用于让父进程等待子进程的状态改变并获取已经改变状态的子进程的信息。\n僵尸态指的是进程终止但是并未释放相关资源的一种状态，此时由系统内核对处于僵尸态的进程进行维护，处于僵尸态的进程会占用创建进程的资源和数量，如果僵尸态进程数量太多，则会导致系统无法创建新进程。\n所以父进程应该及时的对终止的子进程进行等待，这样就可以回收子进程占用的资源，当然，如果父进程终止，则处于僵尸态的子进程会由系统内核完成资源的回收。\n注意：如果当前进程没有子进程，则wait函数立即返回，如果当前进程有很多个子进程则wait函数会回收第一个变为僵尸态的子进程资源。\nwait函数的参数是一个指针，用于记录子进程的退出状态，如果该参数为NULL，则表示当前进程放弃子进程的退出状态。对于该指针中记录的值，用户可以通过系统提供的宏定义来分析子进程的退出状态。\n通过man手册可以发现Linux内核还提供了另一个叫做**waitpid()**的系统调用函数，该函数也可以等待子进程状态改变并回收子进程的系统资源，只不过该函数的针对性更强，可以指定回收某个子进程的系统资源。\n练习：编程产生一个进程链，父进程派生一个子进程后，输出自己的PID，然后退出，该子进程继续派生子进程，然后打印PID，然后退出，以此类推，要求父进程比子进程先输出PID\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main(int argc, const char *argv[]) { int i=2; while( i-- ){ // 创建一个子进程 pid_t pid = fork(); // fork()函数返回值的判断 if(pid\u0026gt;0){// 父进程 wait(NULL); // 等待子进程结束 printf(\u0026#34;Parent process, pid: %d,My child pid: %d\\n\u0026#34;, getpid(), pid); }else if(pid==0){// 子进程 printf(\u0026#34;Child process, pid: %d,My parent pid: %d\\n\u0026#34;, getpid(), getppid()); break; } else{ perror(\u0026#34;fork error\u0026#34;); return -1; } } return 0; } Child process, pid: 3296,My parent pid: 3295 Parent process, pid: 3295,My child pid: 3296 Child process, pid: 3297,My parent pid: 3295 Parent process, pid: 3295,My child pid: 3297 要是子进程忘记加break，由于fork()时，会复制父进程的数据段和代码段\n导致子进程中也会存在循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, const char *argv[]) { int i=2; while( i-- ){ // 创建一个子进程 pid_t pid = fork(); // fork()函数返回值的判断 if(pid\u0026gt;0){// 父进程 wait(NULL); // 等待子进程结束 printf(\u0026#34;Parent process, pid: %d,My child pid: %d\\n\u0026#34;, getpid(), pid); }else if(pid==0){// 子进程 printf(\u0026#34;Child process, pid: %d,My parent pid: %d\\n\u0026#34;, getpid(), getppid()); } else{ perror(\u0026#34;fork error\u0026#34;); return -1; } } return 0; } Child process, pid: 3233,My parent pid: 3232 Child process, pid: 3234,My parent pid: 3233 Parent process, pid: 3233,My child pid: 3234 Parent process, pid: 3232,My child pid: 3233 Child process, pid: 3235,My parent pid: 3232 Parent process, pid: 3232,My child pid: 3235 进程的执行 既然在一个进程中可以创建多个子进程，并且子进程和父进程的数据段和代码段是相同的，也就是一份程序会执行两次，一般情况下是没有意义和必要的，请问能否让子进程单独的加载新的程序的代码段和数据段，如果可以，应该如何实现？\n当然是可以的，Linux系统标准库中提供了一组函数接口来实现在进程中加载和执行指定的程序。\n这组接口可以把exec作为前缀，然后以exec后面的字符进行分类，比如l指的是list的缩写，p指的是path的缩写，e指的是environment的缩写，v指的是vector的缩写。\n(1) l : 以列表的方式来组织指定程序的参数\n(2) v: 以数组的方式来组织指定程序的参数\n(3) e: 执行指定程序前顺便设置环境变量\n(4) p: 执行程序时可自动搜索环境变量PATH的路径\n以 execl(const char pathname, const char arg, \u0026hellip;) 为例，参数pathname是需要加载的指定程序**，而arg则是该程序运行时的命令行参数，命令行参数包括程序名本身，并且全部是字符串，其实和带参数的main函数通过命令行传参的流程类似，但是函数的参数列表必须以NULL结束，也就是函数的最后一个参数填NULL即可。\n练习：编写一个程序，使之产生一个子进程，在子进程中执行系统命令ls -l去查看某个文件的信息，父进程判断子进程是否执行成功。要求父进程等待子进程结束之后再结束。提示：Linux系统中的shell命令属于可执行文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026#34;sys/wait.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, const char *argv[]) { // 创建一个子进程 pid_t pid = fork(); // fork()函数返回值的判断 if(pid\u0026gt;0){// 父进程 printf(\u0026#34;Parent process, pid: %d,My child pid: %d\\n\u0026#34;, getpid(), pid); wait(NULL); printf(\u0026#34;child process end\\n\u0026#34;); } else if(pid==0){// 子进程 printf(\u0026#34;Child process start, pid: %d\\n\u0026#34;, getpid()); //execl(\u0026#34;/bin/ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL); system(\u0026#34;ls -l\u0026#34;); }else{ perror(\u0026#34;fork error\u0026#34;); return -1; } return 0; } 其实，linux系统还提供一个函数，名称叫做system()，这个函数也可以让新进程执行shell命令。 ","date":"2026-02-07T20:42:15+08:00","image":"https://gxpdev.dpdns.org/PicGo/消息队列.png","permalink":"https://guokun603.github.io/p/%E5%B5%8C%E5%85%A5%E5%BC%8F-linux-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BB%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A5%A5%E7%A7%98/","title":"嵌入式 Linux 程序与进程：从静态代码到动态执行的奥秘"},{"content":"嵌入式 Linux 进程间通信之管道通信：匿名与命名管道的奥秘 进程间通信与管道通信概述 进程间通信 进程间通信（Inter Process Communication，简称IPC）指的是进程之间的信息交换，进程间通信的方式有很多，比如管道通信、信号通信、共享内存、消息队列、信号量组、POSIX信号量等。\n进程间通信可以达到数据传输、共享资源、控制进程等目的，方便用户对进程进行控制和管理。而管道通信是其中最基础、最易上手的一种。\n管道通信 Linux中的管道通信，核心特点是半双工通信，同一时刻只能“发送数据”或“接收数据”中的一个操作，无法双向同步同时通信。就像现实中的水管，水只能从一端流向另一端，不能双向对流。\n设计理念非常简单：模拟现实中的“管道”，让数据从一端写入、另一端读出，实现进程间的单向数据传递，适合简单的场景下的数据交互。\n管道在Linux系统中属于“文件”的一种，但它又不是普通文件，而是一种“特殊文件”。它支持和普通文件一样的read()/write()操作，但不支持lseek()（无法指定位置读写），数据写入管道后会暂存在内核缓冲区，读取后就会从缓冲区中删除，不会持久化存储。\nLinux系统中的管道文件分为两种：匿名管道(pipe)、命名管道(fifo)。\n匿名管道（pipe）：亲缘进程的“秘密通道” 匿名管道，顾名思义，没有文件名，这是它最核心的特征，也决定了它的使用局限性：\n无文件名，无法通过open()函数创建和打开，只能通过专门的系统调用创建。 仅适用于有亲缘关系的进程（最常用的是父子进程），无法用于无亲缘关系的进程间通信。 数据读写方式和普通文件一致，支持read()/write()操作。 不保证数据的原子性，多进程同时写入时可能出现数据错乱。 问题：匿名管道无文件名，如何创建和访问？\nLinux系统提供pipe()系统调用，专门用于创建匿名管道；创建成功后，会返回两个文件描述符，\n分别对应管道的“读取端”和“写入端”，进程通过这两个文件描述符就能访问管道。\npipe()函数创建匿名管道 pipe()函数只有一个参数 int pipefd[2]，这是一个长度为2的数组，专门用于存储管道的两个文件描述符：\npipefd[0]：对应管道的读取端，只能用于read()操作，无法写入。 pipefd[1]：对应管道的写入端，只能用于write()操作，无法读取。 用户把对数据写入到管道之后，数据是会在内核的缓冲区中进行暂存的，直到从管道中读取该数据为止。\n匿名管道的核心工作机制 内存暂存：进程向管道写入数据后，数据不会直接传递给进程接收，而是先暂存在内核缓冲区，知道接收进程调用read()读取数据，数据才会从缓冲区移除\n缓冲区大小：Linux系统中，管道的内核缓冲区默认大小是4M，可以使用ulimit -a查看\n阻塞特性：\n写入阻塞：如果写入速度快于读取速度，内核缓冲区会被写满，此时继续调用write()写入数据，进程会被阻塞（挂起），直到缓冲区有空闲空间。 读取阻塞：如果读取速度快于写入速度，管道内（缓冲区）没有数据时，继续调用read()读取数据，进程会被阻塞（挂起），直到有新的数据写入管道。 阻塞的意义：阻塞状态会让当前进程挂起，释放CPU资源，让其他需要CPU的进程高效利用资源，从而提高整个系统的吞吐量，这是Linux系统资源调度的重要优化。\n问题：匿名管道适用于什么场景？什么时候创建最合适？\n由于管道没有文件名，所以仅适合有亲缘关系的进程（父子、兄弟），因为这类进程可共享文件描述符，无需通过文件定位管道。\n必须在创建子进程（fork()）之前创建匿名管道。因为fork()创建子进程时，会复制父进程的代码段、数据段、堆栈段，以及所有打开的文件描述符——如果父进程先创建管道，子进程会自动复制管道的两个文件描述符，这样父子进程就能通过这两个文件描述符访问同一个管道；如果先fork()再创建管道，子进程不会拥有管道的文件描述符，无法访问管道。\n匿名管道不保证数据的原子性\n匿名管道更适合“一对一”的亲缘进程通信，不适合多进程同时写入的场景。\n命名管道（fifo）：无亲缘关系进程的“公共通道” 匿名管道的局限性很明显：只能用于亲缘进程、一对一通信。为了解决这个问题，Linux系统提供了命名管道（Named Pipe），也叫有名管道、具名管道（简称fifo），它弥补了匿名管道的不足，支持无亲缘关系的进程间通信。\n命名管道和匿名管道的核心区别，就是有自己的文件名，这个特点也决定了它的优势：\n有文件名，属于Linux系统中的“管道文件”（可通过ls -l查看，文件类型标识为p）。 支持open()函数打开，读写方式和普通文件一致（read()/write()），但不支持lseek()（无法指定位置读写）。 适用场景：无亲缘关系的进程间通信（比如两个完全独立的程序），也支持有亲缘关系的进程。 支持多路同时写入：多个进程可以同时向同一个命名管道写入数据，且能保证数据的原子性（写入数据量不超过PIPE_BUF时）。 问题：怎么保证数据原子性\n从原理上来说，内核为命名管道维护了一个缓冲区。当进程进行写入操作时，内核会先将数据暂存到这个缓冲区中。如果写入的数据量小于等于 PIPE_BUF，内核会保证这整个写入操作是原子性的。这是因为在这种情况下，内核可以将该写入操作作为一个整体来处理，在这个操作完成之前，不会被其他进程的写入操作打断。\n如果写入的数据量超过了 PIPE_BUF，内核就无法保证原子性了。因为此时数据量较大，内核可能会将其拆分成多个部分来处理，这样就可能出现其他进程在这个大写入操作中间插入自己的写入，导致数据混乱。\nmkfifo()函数创建命名管道 访问命名管道的前提是：命名管道已经存在。Linux系统提供了mkfifo()函数，专门用于创建命名管道。\nconst char *pathname：命名管道的文件路径和名称（如\u0026quot;/tmp/myfifo\u0026quot;）。 重点注意：创建命名管道时，路径必须位于Linux系统内部（比如虚拟机中的Linux目录），不能创建在Windows共享文件夹中—— 因为共享文件夹属于Windows系统路径，Linux的管道机制无法在Windows路径下生效，会导致创建失败。 mode_t mode：命名管道的访问权限，和open()函数的mode参数一致，采用八进制表示，分为三类权限（所有者、所属组、其他用户）。 常用权限：0644（所有者可读可写，其他用户只读）、0666（所有用户可读可写）—— 管道无需执行权限，因此权限的最后一位（执行权限）设为0即可。 总结 管道通信的核心是“半双工”，数据单向流动，暂存在内核缓冲区（默认4M），无持久化 匿名管道：无文件名，依赖亲缘进程，fork()前创建，适合简单的父子进程通信 命名管道：有命管道，支持无亲缘进程通信，需用mkfifo()创建，支持多进程安全写入 重点函数：pipe()/pipe2()（匿名管道）、mkfifo()（命名管道），以及read()/write()的使用。 ","date":"2026-02-07T16:19:53+08:00","image":"https://gxpdev.dpdns.org/PicGo/消息队列.png","permalink":"https://guokun603.github.io/p/%E5%B5%8C%E5%85%A5%E5%BC%8F-linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E5%8C%BF%E5%90%8D%E4%B8%8E%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%A5%A5%E7%A7%98/","title":"嵌入式 Linux 进程间通信之管道通信：匿名与命名管道的奥秘"},{"content":"嵌入式 Linux 系统编程之进程间通信 —— 信号机制深度剖析 信号机制的基础 信号的概念 信号是Unix、类Unix等系统里实现进程通信的一种方式。信号采用的是异步通信的机制。\n当一个信号发送给一个某进程，操作系统就会中断接收到信号的进程，此时进程中任何非原子性的操作都将被中断。\n同步通信：进程发出请求后阻塞等待响应。\n异步通信：指进程发出请求后不等待相应，继续执行其他任务，等待响应时再处理。\n比如去银行办事，异步像取号后可做别的事，叫号了再去办理；同步则是排队一直等。信号机制能提升程序执行效率。\n信号的类型 Linux系统中提供了shell命令: kill - l，该命令的作用是给某个进程发送信号，参数-l可以列出信号的名称\n可以发现Linux系统中的信号编号为164，其中编号为131的信号为普通信号，编号为34~64的信号为实时信号。\n普通信号\nLinux系统中的普通信号也称为不可靠信号，当进程接收多个信号来不及处理，会丢弃多余信号，只保留一个。Linux系统的普通信号是Unix系统继承过来的。\n实时信号\nLinux系统的实时信号也被称为可靠信号，当进程接收多个信号请求时但是不能及时处理，会把未处理的信号形成队列，按照排序依次处理。Linux系统中的实时信号是新增加的。\n信号的含义 在Linux系统中可以查看man手册的第七章查找signal进行了解\n通过kill -l输出的信号名称都是大写的，按照编程规则而言这些信号都是宏定义，另外，可以看到信号前面有一个编号，这个编号就是指信号宏定义的替换列表的值。这些宏定义都被定义在signal.h头文件中\n信号的产生与处理 信号的产生 **按键触发：**在终端，按Ctrl + C可产生SIGINT信号终止前台进程。这是因为按键产生硬件中断，操作系统解释为信号记录在进程 PCB，CPU 处理完中断后处理信号，使进程终止。 在终端正在运行的进程叫做前台进程，用户使用快捷键Ctrl+C只能结束前台进程，无法结束后台进程，如果想把一个进程转为后台执行，则可以在运行程序的时候添加符号 \u0026amp;。\n**硬件异常：**进程执行除以0或者访问非法内存地址等操作引发硬件异常，内核会发出相关信号。\n调用接口：kill()函数可以指定进程发信号，参数为目标进程的IP和信息，成功返回0，失败返回-1。raise()函数只能向当前进程发信号。\n**发送指令：**终端用kill命令发送信号，本质调用kill函数，不指定信号名，默认发SIGTERM信号终止进程。 内核检测：内核检测到如闹钟超时（alarm()函数设置）产生SIGALRM信号，或进程向读端关闭的管道写数据产生SIGPIPE信号 。 信号的处理 当进程接收到信号之后，可以分为三种情况来对信号进行处理，分别是默认、捕捉和忽略。\n**默认处理：**Linux系统对普通信号有默认规定，如果用户没有自定义信号的执行动作，则会采用默认处理的方式对信号进行响应。比如进程接收SIGTERM信号后则会被终止。\n**捕捉信号：**进程可提前设计信号相应函数并关联信号，这样当进程接收到信号之后，就不会执行信号的默认响应动作，而是执行用户指定的响应动作。signal函数用于此，参数为信号编号和处理函数的地址。\n当捕捉到信号时，不论进程的主控制流程当前执行到哪儿，都会先跳到信号处理函数中执行，从信号处理函数返回后再继续执行主控制流程。\n信号处理函数是一个单独的控制流程，因为它和主控制流程是异步的，二者不存在调用和被调用的关系，并且使用不同的堆栈空间。引入了信号处理函数使得一个进程具有多个控制流程，如果这些控制流程访问相同的全局资源（全局变量、硬件资源等），就有可能出现冲突。\nSIGKILL和SIGSTOP信号是不可自定义响应接口。\n忽略信号：调用signal()函数，将第二个参数设为SIG_IGN可忽略信号 。 信号阻塞与挂起机制 信号阻塞 进程又是需要蚕食屏蔽某些信号，如程序执行时不想被Ctrl + C强制结束，可以阻塞该信号。\nLinux系统中提供了一个名称叫做sigprocmask()的函数接口来设置信号集的属性，使用规则如下：\nsigprocmask()函数用于设置信号集属性，实现阻塞、解除阻塞操作。需先创建信号集，添加或删除信号 。\n阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。\n信号挂起 进程只有在运行态才能处理信号，挂起信号集存储待处理信号。其他进程发的信号先放入挂起信号集，等进程被调度运行时再处理 。\n补充知识 原子操作 原子操作（Atomic Operation） 指的是不可被中断、不可被分割的最小执行单元—— 要么整个操作完整执行完毕，要么完全不执行，不会出现 “执行到一半被打断” 的中间状态。\n原子上下文 原子上下文（Atomic Context） 指的是执行流处于 “不可被调度、不可被阻塞” 的执行环境，在这个上下文中，所有操作都必须是原子的，且不能执行任何可能导致阻塞或调度的操作。\n简单总结：原子操作是 “点” 上的原子性，原子上下文是 “段” 上的原子性—— 原子操作是原子上下文的基础，原子上下文要求所有操作都必须是原子的。\n","date":"2026-02-05T21:21:12+08:00","image":"https://gxpdev.dpdns.org/PicGo/消息队列.png","permalink":"https://guokun603.github.io/p/%E5%B5%8C%E5%85%A5%E5%BC%8F-linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","title":"嵌入式 Linux 系统编程之进程间通信 —— 信号机制深度剖析"},{"content":"深入解析嵌入式 Linux 之消息队列：进程间通信的桥梁 消息队列的概念 Linux系统中进程间通信的一种方式，能传输用户自定义类型的数据，相同类型数据按到达顺序排队，不同数据类型数据存于不同队列。\n这里有个关键细节：不同类型的数据不能放在同一个消息队列中。也就是说，系统中可以同时存在多个消息队列，每个队列只存储一种类型的数据；因此，进程读取消息时，必须指定数据类型，才能从对应队列中获取有效数据。\n问题：系统如何管理多个消息队列？进程如何选择队列？\n每个消息队列都有一个唯一的键值(key),这个key就相当于消息队列的“身份证”，进程通过指定key值，就能精准定位到目标消息队列，实现消息的收发。\n在Linux中，使用命令ipcs -a可以查看系统中所有的IPC对象（包含消息队列、共享内存、信号量组）的详细信息。\n创建消息队列：从命令到函数 当系统中不存在目标消息队列时，我们需要先创建它，Linux提供了两种方式：ipcmk命令（快速创建） 和 msgget()函数（编程创建），后者也是实际开发中最常用的方式。\nipcmk命令 该命令用于快速创建IPC对象，创建消息队列的语法如下：\n1 2 ipcmk -Q # -Q 表示创建消息队列，默认权限为0644 ipcmk -Q -m 0666 # 可指定权限（八进制），消息队列无需执行权限 msgget()函数 msgget()函数的作用是：创建一个新的消息队列，或打开一个已存在的消息队列，是编程中操作消息队列的“入口”函数。\n第一个参数需要传入一个key_t类型的值，该值指的是要创建的消息队列的key键值，key也可以称为密钥。 键值类型key_t其实在内核源码中指的是int类型\n第二个参数指的是创建消息队列的标志，其中IPC_CREAT指的是如果消息队列不存在则创建，IPC_EXCL指的是如果消息队列存在则表示函数调用失败。\n另外，也可以指定消息队列的权限，权限的结构和open函数的mode类型，采用八进制表示，只不过消息队列不需要设置执行权限，所以权限设置为****0644****即可。\n问题：key的值由用户自定义可以吗？\n可以由用户指定，但不建议手动指定。因为如果多个进程同时创建消息队列，手动指定的key值可能重复，导致队列创建失败。\n正确做法：由系统生成唯一的key值，Linux提供了ftok()函数，专门用于生成System-V IPC对象的唯一key值。\nftok()函数：生成唯一的键值 ftok()函数的核心逻辑：将一个已存在的文件路径和一个用户指定的项目ID，转换为唯一的key值\n第一个参数指的是系统中已经存在并且可以访问的一个文件的路径，用户可以指定一个文件，但是该文件必须存在且可以被访问，其实就是为了得到文件的属性信息中的inode编号和设备编号，因为Linux系统中一个文件的inode编号是唯一的。\n第二个参数指的是项目ID，这个可以由用户进行指定，虽然参数proj_id的类型是整型int，但是只会用到最低8it，所以这个参数的范围其实是1~255，因为这个参数的值必须是非0值。\nftok()函数生成的键值key的组成：proj_id的低8位+ 设备编号的低8位+ inode编号的低16位。\nstat()函数：获取文件信息 stat()函数用于获取文件的详细属性信息。\n访问消息队列：收发消息（msgsnd() \u0026amp; msgrcv()） 创建消息队列后，进程之间就可以通过它收发消息了。Linux提供了两个核心函数：msgsnd()（发送消息） 和 msgrcv()（接收消息），两者配合使用，实现按类型收发数据。\nmsgsnd()发送消息 msgsnd()函数的作用：将指定类型的消息，发送到指定的消息队列中\n1 2 3 4 #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; int msgsnd(int msgid, const void *msgp, size_t msgsz, int msgflg); // 成功返回0，失败返回-1 int msgid：消息队列的标识符，由msgget()函数返回。\nconst void *msgp：指向消息结构体的指针，该结构体需要用户自定义，必须包含两个成员：\n1 2 3 4 5 // 自定义消息结构体（固定格式，mtype必须是第一个成员，且大于0） struct msgbuf { long mtype; // 消息类型，必须是大于0的正整数（用户自定义） char mtext[1024]; // 消息正文，可自定义长度和类型（如数组、其他结构体） }; size_t msgsz：消息正文（mtext）的大小（按字节计算），可以是0（表示无消息正文，仅传递类型），必须是非负整数。\nint msgflg：发送消息的标志，常用值：\n0：默认阻塞模式。如果消息队列剩余空间不足，进程会阻塞，直到队列有足够空间容纳消息。 IPC_NOWAIT：非阻塞模式。如果队列剩余空间不足，直接返回-1，并设置错误码（EAGAIN），不阻塞进程。 msgrcv()接收消息 msgrcv()函数的作用：从指定的消息队列中，接收指定类型的消息\n1 2 3 4 #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; ssize_t msgrcv(int msgid, void *msgp, size_t msgsz, long msgtyp, int msgflg); // 成功返回接收的字节数，失败返回-1 int msgid：消息队列的标识符（同msgsnd()）。 void *msgp：存放接收消息的缓存区，类型为自定义的msgbuf结构体指针（与发送时的结构体一致）。 size_t msgsz：缓存区（mtext）的大小（按字节计算），如果消息正文长度大于msgsz，需通过msgflg控制处理方式。 long msgtyp：要接收的消息类型，核心参数，有三种取值方式： msgtyp = 0：不区分类型，接收队列中的第一个消息（先进先出）。 msgtyp \u0026gt; 0：接收类型为msgtyp的第一个消息；若配合msgflg=MSG_EXCEPT，则接收除msgtyp之外的第一个消息。 msgtyp \u0026lt; 0：接收类型小于等于msgtyp绝对值的第一个消息（取最小类型）。例如：msgtyp=-3，会接收类型为1、2、3中最小类型的第一个消息。 int msgflg：接收消息的标志，常用值： 0：默认阻塞模式，若队列中无指定类型的消息，进程会阻塞，直到有对应消息。 IPC_NOWAIT：非阻塞模式，无对应消息时直接返回-1，不阻塞。 MSG_EXCEPT：与msgtyp\u0026gt;0配合，接收除msgtyp之外的第一个消息。 MSG_NOERROR：如果消息正文长度大于msgsz，截断消息，只接收msgsz字节，不报错（否则返回-1）。 函数 默认阻塞场景 非阻塞方式 错误码（非阻塞时） msgsnd() 消息队列满（字节数 / 消息数达上限） `msgflg = IPC_NOWAIT` EAGAIN msgrcv() 队列中无符合 msgtyp 的消息 `msgflg = IPC_NOWAIT` ENOMSG 实操练习：进程间通过消息队列+信号通信 需求：设计两个进程（A和B），实现以下逻辑：\n进程A创建一个消息队列，然后向进程B发送SIGUSR1信号（通知B队列已创建）。 进程B捕获SIGUSR1信号后，打开该消息队列，将自己的PID作为消息正文，发送到消息队列中。 进程B发送消息后，向进程A发送SIGUSR2信号（通知A消息已发送）。 进程A捕获SIGUSR2信号后，从消息队列中读取消息，输出消息正文（进程B的PID）。 进程A\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;signal.h\u0026gt; // UNIX 系统调用头文件（按功能分类） #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; int flag = 0; struct msgbuf { long mtype; //消息类型，必须大于0 int mtext; //消息正文 }first; pid_t pid_A; pid_t pid_B; void signal_handler(int signum) { if (signum == SIGUSR2) { printf(\u0026#34;【进程A】收到来自进程B的SIGUSR2信号\\n\u0026#34;); flag = 1; } } int main(int argc, char *argv[]) { //创建有命名管道 int mkfifo_result = mkfifo(\u0026#34;./myfifo\u0026#34;, 0666); if (mkfifo_result == -1) { fprintf(stderr,\u0026#34;Fifo created failed,error[%d],%s\\n\u0026#34;,errno,strerror(errno)); return 1; } printf(\u0026#34;【进程A】命名管道创建成功：%s\\n\u0026#34;, \u0026#34;./myfifo\u0026#34;); //打开有命名管道 int fd = open(\u0026#34;./myfifo\u0026#34;, O_WRONLY); if (fd == -1) { fprintf(stderr, \u0026#34;Failed to open FIFO: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } //向有命名管道写入自己的pid_A pid_A = getpid(); char pid_str[32]; sprintf(pid_str, \u0026#34;%d\u0026#34;, pid_A); write(fd, pid_str, strlen(pid_str)+1); close(fd); printf(\u0026#34;【进程A】已向管道写入自己的PID：%s\\n\u0026#34;, pid_str); //打开管道读取B的pid int fd_read = open(\u0026#34;./myfifo\u0026#34;, O_RDONLY); if (fd_read == -1) { fprintf(stderr, \u0026#34;Failed to open FIFO for reading: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } char buffer[32]; int bytes_read = read(fd_read, buffer, sizeof(buffer)-1); if (bytes_read \u0026gt; 0) { buffer[bytes_read] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;【进程A】从管道读取到的B的PID: %s\\n\u0026#34;, buffer); } else { fprintf(stderr, \u0026#34;Failed to read from FIFO: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); } close(fd_read); //获取KEY key_t key = ftok(\u0026#34;.\u0026#34;, 1); //创建消息队列 int msgid = msgget(key, IPC_CREAT | 0666); if (msgid == -1) { fprintf(stderr, \u0026#34;Failed to create message queue: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } printf(\u0026#34;【进程A】消息队列创建成功，msgid: %d\\n\u0026#34;, msgid); //向进程B发送信号 pid_B = atoi(buffer); if (kill(pid_B, SIGUSR1) == -1) { fprintf(stderr, \u0026#34;Failed to send signal to B: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } printf(\u0026#34;【进程A】已向进程B发送SIGUSR1信号\\n\u0026#34;); signal(SIGUSR2, signal_handler); while (!flag); if (flag) { if (msgrcv(msgid, \u0026amp;first, sizeof(first.mtext), 1, 0) == -1) { fprintf(stderr, \u0026#34;Failed to receive message: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } printf(\u0026#34;【进程A】从消息队列收到消息，内容为：%d\\n\u0026#34;, first.mtext); } return 0; } 进程B\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;signal.h\u0026gt; // UNIX 系统调用头文件（按功能分类） #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; int flag = 0; struct msgbuf { long mtype; //消息类型，必须大于0 int mtext; //消息正文 }first; pid_t pid_A; pid_t pid_B; void signal_handler(int signum) { if (signum == SIGUSR1) { printf(\u0026#34;【进程B】收到来自进程A的SIGUSR1信号\\n\u0026#34;); flag = 1; } } int main(int argc, char *argv[]) { //打开有命名管道读取A的pid int fd = open(\u0026#34;./myfifo\u0026#34;, O_RDWR); if (fd == -1) { fprintf(stderr, \u0026#34;Failed to open FIFO for reading: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } char buffer[32]; int bytes_read = read(fd, buffer, sizeof(buffer)-1); if (bytes_read \u0026gt; 0) { buffer[bytes_read] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;【进程B】从管道读取到的A的PID: %s\\n\u0026#34;, buffer); pid_A = atoi(buffer); } else { fprintf(stderr, \u0026#34;Failed to read from FIFO: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); } //向有命名管道写入自己的pid pid_B = getpid(); char pid_str[32]; sprintf(pid_str, \u0026#34;%d\u0026#34;, pid_B); write(fd, pid_str, strlen(pid_str)+1); printf(\u0026#34;【进程B】已向管道写入自己的PID：%s\\n\u0026#34;, pid_str); close(fd); // 获取消息队列 key_t key = ftok(\u0026#34;.\u0026#34;, 1); int msgid = msgget(key, 0666); if (msgid == -1) { fprintf(stderr, \u0026#34;Failed to create message queue: error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } signal(SIGUSR1, signal_handler); while(!flag); if(flag){//发送消息队列 first.mtype = 1; first.mtext = pid_B; msgsnd(msgid, \u0026amp;first, sizeof(first.mtext), 0); printf(\u0026#34;【进程B】已向消息队列发送消息，内容为：%d\\n\u0026#34;, first.mtext); //向进程A发送信号 if (kill(pid_A, SIGUSR2) == -1) { fprintf(stderr, \u0026#34;Failed to send signal to A : error[%d],%s\\n\u0026#34;, errno, strerror(errno)); return 1; } printf(\u0026#34;【进程B】已向进程A发送SIGUSR2信号\\n\u0026#34;); } return 0; } 这里我是用了，管道来发送和接收对方的PID，因为使用信号通信，所以用管道来接收PID\n控制消息队列：删除与属性管理（msgctl()） IPC对象（包括消息队列）是持久性资源，不会随进程终止而自动销毁，必须手动删除，否则会一直占用系统资源，导致资源泄露。\nLinux提供了msgctl()函数，用于管理消息队列，支持三种操作：获取队列属性、设置队列属性、删除队列（最常用）。\n指令删除（快速清理用） 终端中使用ipcrm命令，可快速删除消息队列，语法如下：\n1 2 ipcrm -q msgid # 通过msgid删除（最精准，msgid可通过ipcs -q查看） ipcrm -Q key # 通过key值删除 函数控制（编程核心） msgctl()函数语法如下：\n1 2 3 4 #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; int msgctl(int msgid, int cmd, struct msqid_ds *buf); // 成功返回0，失败返回-1 int msgid：消息队列的标识符。 int cmd：要执行的操作命令，常用值： IPC_RMID：删除消息队列（最常用），删除后队列不可再访问，所有未读取的消息会被清空。 IPC_STAT：获取消息队列的属性（如队列容量、消息数量），存储到buf指向的msqid_ds结构体中。 IPC_SET：设置消息队列的属性（如权限），通过buf指向的msqid_ds结构体配置。 struct msqid_ds *buf：指向msqid_ds结构体的指针，用于存储/设置队列属性；如果cmd=IPC_RMID，可设为NULL（无需属性）。 1 2 3 4 5 6 // 删除msgid对应的消息队列 if (msgctl(msgid, IPC_RMID, NULL) == -1) { perror(\u0026#34;msgctl error\u0026#34;); // 报错提示 exit(-1); } printf(\u0026#34;消息队列删除成功\\n\u0026#34;); 总结 消息队列的核心优势：按类型收发数据，支持结构化交互，是System-V IPC对象之一。 三个核心函数：msgget()（创建/打开队列）、msgsnd()/msgrcv()（收发消息）、msgctl()（删除/管理队列）。 关键细节：key值的生成（ftok()函数）、消息类型的指定、队列的手动删除（避免资源泄露）。 ","date":"2026-02-07T11:26:49+08:00","image":"https://gxpdev.dpdns.org/PicGo/消息队列.png","permalink":"https://guokun603.github.io/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B5%8C%E5%85%A5%E5%BC%8F-linux-%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A1%A5%E6%A2%81/","title":"深入解析嵌入式 Linux 之消息队列：进程间通信的桥梁"},{"content":"无人机飞控设计 控制核心采用STM32F103C8T6，姿态运动传感器选择MPU6050。无人机通过Si24R1（NRF24L01）与遥控器进行2.4G无线通信，实现了即时有效地接遥控器指令，通过串级PID进行姿态控制，从而在空间中实现自由移动。\n飞控原理图 主控芯片\nSTM32F103C8T6\n最小电路\n3.3V供电 复位按钮 烧录引脚 - - - -\u0026gt;STLIND0 外接晶振 陀螺仪MPU6050\n使用I2C1进行通信 2.4G无线通信\n采用Si24R1，2.4G无线通信 采用SPI1连接主控芯片 外界16MHZ晶振 激光测高\n采用VL53L4CD0DH测距传感器 I2C2接线 锂电池充放电管理模块\nTP4336芯片 充电管理芯片 AMS1117-3.3V 降压芯片 锂电池插座 电机插槽\n驱动四个电机 PWM mos驱动 电压更加稳定 信号灯和监控电池电压\n开发板周围4个信号灯 由于ADC的量程上限是3.3v，没有办法直接测量，所以采用分压电路 PCB 绘制板框\n布局元件\n按键和接口放置在开发板边缘\n主控芯片尽量在中间位置\nMPU6050陀螺仪芯片必须在中间\n布线 布线顺序，还是比较重要的，从电源布线一步步来\n电源布线\nVCC主供电\nVBAT\n5V输出\n降压稳压芯片\n输入5V 输出3.3V 主控芯片最小电路\nMPU6050陀螺仪布线\n测量电池电压\n电机插座\n红外激光测距\n2.4G通讯\nled灯和接口\n天线布线\n特定尺寸 需要直接导入封装\n尺寸严格 不能修改\nGND铺铜网络\n孤岛区域需要单独连接\n打通孔提高载流能力\n美化开发板\n调整丝印\n添加文字\n泪滴工具 =\u0026gt; 有效提高稳定性 提高载流能力\n成品\n感受 布线还是太折磨人了，一直在打孔，调整线的位置。\n但是当你布好所有线时，会有很强的成就感\n","date":"2026-02-04T16:45:10+08:00","image":"https://gxpdev.dpdns.org/PicGo/PCB背景图1.png","permalink":"https://guokun603.github.io/p/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E6%88%91%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%A3%9E%E6%8E%A7-pcb-%E8%AE%BE%E8%AE%A1%E5%85%A8%E8%BF%87%E7%A8%8B/","title":"从零到一：我的无人机飞控 PCB 设计全过程"},{"content":"前言 本教程将介绍如何使用 Hugo 和 GitHub Pages 搭建一个静态博客。Hugo 是一款功能强大的静态站点生成器，可以帮助您轻松创建美观、响应式的博客页面。GitHub Pages 则是 GitHub 提供的免费托管服务，可用于托管您的 Hugo 博客。\n环境搭建 首先s下载所需的工具：\n[Hugo](The world\u0026rsquo;s fastest framework for building websites)\n[Git](Git - 安装 - Git 版本控制系统)\n[Go](Download and install - The Go Programming Language)\n将Hugo和Git的指令添加环境变量\n创建博客 创建Hugo新站点 使用 Hugo 创建新站点非常简单，在想要创建的目录下，命令行中输入以下命令：\n1 hugo new site blog 其中blog 是博客名称，可以根据需要修改。\n执行该命令后，会自动生成 Hugo 博客的标准目录结构，生成的目录如下：\n1 2 3 4 5 6 7 8 9 10 blog/ ├── archetypes/ # 内容模板（新建文章时的默认格式） ├── assets/ # 未编译的静态资源（如 SCSS、JS） ├── hugo.toml # 核心配置文件（Toml 格式，也可改用 Yaml/Json） ├── content/ # 博客文章内容（核心目录，放 Markdown 文章） ├── data/ # 自定义数据文件（如 JSON/Yaml，可在模板中调用） ├── layouts/ # 自定义模板（覆盖主题模板） ├── public/ # 编译后生成的静态网站文件（部署用） ├── static/ # 静态资源（如图片、CSS、JS，会直接复制到 public） └── themes/ # 主题文件夹（存放下载的 Hugo 主题） 这将创建必要的配置文件和文件夹，并提示接下来如何创建一个博客。\n进入新创建的站点目录，并运行以下命令进行初始化：\n1 cd blog 选择主题（Hugo module) 浏览和选择主题 Hugo 提供了丰富的主题模板，您可以根据自己的喜好选择合适的主题。\n官方主题仓库 第三方主题仓库\n下载及应用主题(官方推荐，Hugo module) 用这种方法，目录下不会有文件。要修改主题，你需要把想修改的文件复制到目录下的同一个目录。themes``layouts\n不是很推荐，想要自己配置的可以使用，如果想要快速使用的话，查看3.Git配置\n这里演示stack主题，通过[官方文档下载](Getting Started | Stack)\n最低要求的 Hugo 版本可以在主题的 theme.toml 文件中看到\n1 git init 首先，把你的网站变成Hugo模块（如果你还没做过）：\n1 hugo mod init github.com/me/my-new-blog github.com/你的用户名/你的博客名，随便填也可以\n执行成功后，项目根目录会生成一个 go.mod 文件，这是 Hugo Module 的核心配置文件，不用手动修改。\n在项目根目录的 hugo.toml 文件中，添加\n1 2 [[module.imports]] path = \u0026#34;github.com/CaiJimmy/hugo-theme-stack/v3\u0026#34; 这使得 Hugo 使用了主题的最新稳定版本（发布页面可获得，可能不会与分支中最新的提交时间重合）\n要将主题更新到最新版本，请执行以下命令：\n1 2 hugo mod get -u github.com/CaiJimmy/hugo-theme-stack/v3 hugo mod tidy 由于版本问题，在项目根目录执行命令，指定降级到稳定兼容版（v3.28.0 经测试适配 Hugo 0.15x 系列）：\n1 2 hugo mod get github.com/CaiJimmy/hugo-theme-stack/v3@v3.28.0 hugo mod tidy 预览主题 1 hugo server -D 成功是上面那样，这将在您的浏览器中打开一个本地服务器，您可以访问 http://localhost:1313 来查看您的博客页面。\n效果如下：\n这样的话一切内容就需要自己配置，非常麻烦。\n选择主题（Git配置） 下载合适的安装包 1 2 3 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack cd themes/hugo-theme-stack git checkout tags/v3.28.0 这种方法，就是将主题放到了themes中\n应用主题 进入到\\themes\\hugo-theme-stack\\exampleSite中，这里面是官方给的stack案例\n将其中的content文件和hugo.yaml文件一起复制到博客的根目录\n由于hugo.toml和hugo.yaml性质一样，删除原先的hugo.toml\n就可以快速配置好一个默认的页面\n1 hugo server -D 可以访问 http://localhost:1313 来查看您的博客页面。\n设置配置文件 Hugo 的配置文件hugo.yaml用于配置站点信息、主题、菜单等。\n修改里面的内容，就可以将这个页面换为自己的内容\n具体怎么配置可以查看bilibili博主Letere-莱特雷stack主题配置_哔哩哔哩_bilibili\n部署到 GitHub Pages 部署准备 首先,前往【Github官网】，创建仓库 {github用户名}.github.io这将是你博客的主域名。 在将您的 Hugo 博客部署到 GitHub Pages 之前，请确保您已经：\n创建了一个 GitHub 账户。 创建一个新的 GitHub 仓库。 常规部署 首先，修改我们的hugo.yaml中baseurl中的地址，修改为我们创建的仓库的地址，格式如下\n1 baseurl: https://你的仓库/ 然后把public 静态资源文件夹删除\n重新生成静态站点，会自动生成新的public 静态资源文件夹\n1 hugo -D 现在,我们进入public ，就可以将Hugo生成的静态网站文件推送到GitHub仓库:\n1 2 3 4 5 6 7 cd public git init git remote add origin git@github.com:your-github-username/your-github-project-name.git git add . git branch -M main git commit -m \u0026#34;First commit\u0026#34; git push origin main 前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址\n上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客\n自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic) 主页的setting （3）token选择永不过期，并勾选 repo 和 workflow 选项，记得复制一下 为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置\n在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main stack进阶 浏览器搜索Stack主题美化,查看大佬的配置\nHugo + Stack 主题美化指南 🎨\n【博客装修日记】Hugo➕ Stack ➕ Giscus魔改美化 细节满满\n搭建图床 图床概述 图床就是一个专门用来存放图片并提供在线访问链接的服务或工具，你可以把它理解成 “图片的网盘”。\n简单来说，当你在写文章或发帖子时，直接插入本地图片只能在自己的设备上看到。但用图床上传后，它会给你一个公开的图片链接，任何人在任何设备上都能通过这个链接看到图片。\n对于博客场景来说，图床的选择会更看重稳定性、速度、长期可用性和链接的可靠性，因为你的博客内容会长期在线，图片链接一旦失效会直接影响阅读体验。\n推荐 CloudflareR2+ PicGo 简单说就一个核心：免费、稳定、国内访问快，还能一键自动上传，新手零门槛\n具体步骤 注册并开通 Cloudflare R2 前往 Cloudflare 注册账号，并绑定支付方式（如信用卡或 PayPal）。\n登录后，进入 R2 对象存储，点击开通服务。\n创建存储桶 在 R2 控制台中，创建一个存储桶： 填写存储桶名称。 选择存储区域（建议默认）。 确认后完成创建。\n配置自定义域名 设置访问桶的域名，有两种方法，一种是有一个私有域名（需托管在Cloudflare上），另一个是用默认的\n先允许公网访问，启用后，通过公共开发URL将该R2桶的内容暴露到互联网。 这样配置后，就搭建好图床，使用的默认域名。\n可以上传图片\n上传图片后，点击链接，就可以看图片的详情\n可以得到，图片的公网地址\n​ 自定义域名，得有自己的域名\n就实现了，自己的域名访问\n配置 PicGo 下载并安装 PicGo。\n在 PicGo 中安装 Amazon S3 插件：\n打开插件设置，选择 S3 -IIS 1.0.2。 点击图床设置，找到Amazon S3 ，填写相应的信息 应用密钥ID、应用密钥\n自定义节点、域名\n自定义节点,账号ID就是上图的ID\n1 https://\u0026lt;账户ID\u0026gt;.r2.cloudflarestorage.com 自定义域名\n1 https://你的自定义域名 配置完成后，可直接拖拽图片到 PicGo 上传，生成的链接会自动复制到剪贴板。\n","date":"2026-02-01T00:34:38+08:00","image":"https://gxpdev.dpdns.org/PicGo/Hugo+Github.png","permalink":"https://guokun603.github.io/p/hugo-build-blog/","title":"Hugo搭建博客"}]